commonfields:
  id: PICUS
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: PICUS
display: PICUS
category: Network Security
image: data:image/png;base64,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
description: Continuous Breach And Attack Simulation
detaileddescription: https://www.picussecurity.com/
configuration:
- display: PICUS URL
  name: server
  defaultvalue: https://|HOST|
  type: 0
  required: true
  additionalinfo: 'For example : https://192.168.100.100/'
- display: API Key - Refresh Token
  name: apikey
  type: 4
  required: true
  additionalinfo: Picus Interface  - SETTINGS -  ADVANCED - API TOKEN - Generate and
    Show Token
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  script: |-
    import os
    import json
    import requests
    import traceback
    import urllib
    import re
    from requests.exceptions import HTTPError, ConnectionError

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARIABLES'''
    VERIFY_SSL = not demisto.params().get('insecure', False)

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    def test_module() -> str:
        """Tests API connectivity and authentication'

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        :type client: ``Client``
        :param Client:

        :type name: ``str``
        :param name:

        :return: 'ok' if test passed, anything else will fail the test.
        :rtype: ``str``
        """

        try:
            SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
            else demisto.params().get('server')
            SERVER = demisto.params().get('server')
            CREDENTIALS = demisto.params().get('apikey')
            AUTH_HEADERS = {'Content-Type': 'application/json'}

            params = "Bearer " + CREDENTIALS
            headers = {"X-Refresh-Token":params}
            endpoint = "/authenticator/v1/access-tokens/generate"
            url = SERVER + endpoint
            req = requests.post(url, headers=headers, verify=VERIFY_SSL)
            parsed = json.loads(req.content)
            data = parsed['data']
            accessToken = data['access_token']

        except DemistoException as e:
            if ('Forbidden' in str(e)) or not(accessToken):
                return 'Authorization Error: make sure API Key is correctly set'
            else:
                raise e
        return 'ok'


    def getAccessToken():
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        ''' GLOBAL VARS '''
        CREDENTIALS = demisto.params().get('apikey')
        AUTH_HEADERS = {'Content-Type': 'application/json'}


        params = "Bearer " + CREDENTIALS
        headers = {"X-Refresh-Token":params}
        endpoint = "/authenticator/v1/access-tokens/generate"
        url = SERVER + endpoint
        req = requests.post(url, headers=headers, verify=VERIFY_SSL)
        if req.status_code==200:
            pass
        else:
            demisto.results(req.content)
            sys.exit(1)

        parsed = json.loads(req.content)
        data = parsed['data']
        accessToken = data['access_token']
        expirydate = data['expire_at']
        #print("Access Token Expiry Date : ", expirydate)
        results = parsed['data']

        return accessToken

    ''' Token instead of accesstoken
        if TOKEN:
            AUTH_HEADERS['SEC'] = str(TOKEN)


        if not TOKEN :
            raise Exception('Either credentials or auth token should be provided.')

        if not demisto.params()['proxy']:
            del os.environ['HTTP_PROXY']
            del os.environ['HTTPS_PROXY']
            del os.environ['http_proxy']
            del os.environ['https_proxy']
    '''

    def vectorCompare(requestContent):

        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/attack-results/compare-a-vector"

        accessToken = "Bearer " + requestContent
        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        begin_date = demisto.args().get('begin_date')
        end_date = demisto.args().get('end_date')
        trusted = demisto.args().get('trusted')
        untrusted = demisto.args().get('untrusted')
        data = { 'begin_date':begin_date,
                 'end_date':end_date,
                 'trusted':trusted,
                 'untrusted':untrusted,
        }

        cookies = {'X-Api-Token': accessToken}
        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results_insecures = parsed['data']['variants'][0]['insecures'] if 'data' in parsed else ''

        return {
            'Type': entryTypes['note'],
            'Contents': results_insecures,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Insecures', results_insecures)
            }

        results_insecure_to_secures = parsed['data']['variants'][0]['insecure_to_secures'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results_insecure_to_secures,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Insecure to Secures', results_insecure_to_secures)
            }

        results_secure_to_insecures = parsed['data']['variants'][0]['secure_to_insecures'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results_secure_to_insecures,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Secures to Insecure', results_secure_to_insecures)
            }

        results_secures = parsed['data']['variants'][0]['secures'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results_secures,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Secures', results_secures)
            }

    '''Response:
    {
      "data": {
        "trusted": "string",
        "untrusted": "string",
        "variants": [
          {
            "insecure_to_secures": [
              {
                "md5": "string",
                "name": "string",
                "since": "string",
                "threat_id": "string"
              }
            ],
            "insecures": [
              {
                "md5": "string",
                "name": "string",
                "since": "string",
                "threat_id": "string"
              }
            ],
            "secure_to_insecures": [
              {
                "md5": "string",
                "name": "string",
                "since": "string",
                "threat_id": "string"
              }
            ],
            "secures": [
              {
                "md5": "string",
                "name": "string",
                "since": "string",
                "threat_id": "string"
              }
            ],
            "variant_name": "string"
          }
        ]
      },
      "success": true
    }
    '''



    def attackResultList(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/attack-results/list"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        attack_result = demisto.args().get('attack_result')
        begin_date = demisto.args().get('begin_date')
        console_output_info = bool(demisto.args().get('console_output_info'))
        end_date = demisto.args().get('end_date')
        from_time = demisto.args().get('from_time')
        page = int(demisto.args().get('page'))
        size = int(demisto.args().get('size'))
        threat_parameters = demisto.args().get('threat_parameters')
        vector1 = demisto.args().get('vector1')
        vector2 = demisto.args().get('vector2')

        data = { 'attack_result':attack_result,
                 'begin_date':begin_date,
                 'console_output_info':console_output_info,
                 'end_date':end_date,
                 'from_time':from_time,
                 'page':page,
                 'size':size,
                 'threat_parameters':threat_parameters,
                 'vectors':[{'trusted':vector1,
                            'untrusted':vector2
                 }]
        }

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)
        results = parsed['data']['results'] if 'data' in parsed else ''

        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Picus-Attack-Result-List', results)
            }
    '''Response:
    {
      "attack_result": "secure",
      "begin_date": "2018-10-29",
      "console_output_info": true,
      "end_date": "2019-10-29",
      "from_time": "2017-10-29T04:48:35.919615635Z",
      "page": 5,
      "size": 10,
      "threat_parameters": {
        "begin_date": "2018-10-29",
        "categories": [
          [
            "Malicious Code"
          ],
          [
            "Attack Scenario",
            "Defense Evasion",
            "Indicator Removal from Tools"
          ]
        ],
        "cve": "string",
        "end_date": "2019-10-29",
        "kill_chains": [
          "Delivery",
          "Compromise"
        ],
        "md5": "stringstringstringstringstringst",
        "method": "PCI and PII",
        "severity": "High",
        "sha256": "string",
        "threat_id": 100682
      },
      "vectors": [
        {
          "trusted": "Trusted-Peer-Name",
          "untrusted": "Untrusted-Peer-Name"
        }
      ]
    }
    '''



    def specificThreatsResults(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/attack-results/threat-specific-latest"


        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        cve = demisto.args().get('cve')
        md5 = demisto.args().get('md5')
        page = int(demisto.args().get('page'))
        sha256 = demisto.args().get('sha256')
        size = int(demisto.args().get('size'))
        threat_id = int(demisto.args().get('threat_id'))

        data = { 'cve':cve,
                 'md5':md5,
                 'page':page,
                 'sha256':sha256,
                 'size':size,
                 'threat_id':threat_id,
        }

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)
        results = parsed['data']['results'] if 'data' in parsed else ''

        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Picus-Specific-Threats-Results', results)
            }

    '''Response:
    {
      "data": {
        "page_number": 2,
        "results": {
          "CVE": "string",
          "MD5": "string",
          "SHA256": "string",
          "l1_category_name": "string",
          "pid": "string",
          "threat_name": "string",
          "vectors": [
            {
              "id": 0,
              "name": "string",
              "variants": [
                {
                  "destination_port": 443,
                  "last_time": "2017-10-29T08:38:53.1035948Z",
                  "name": "HTTP",
                  "result": "Secure",
                  "since": "2017-10-29T08:38:53.1035948Z",
                  "source_port": 12255
                }
              ]
            }
          ]
        },
        "size": 5,
        "total_count": 548
      },
      "success": true
    }
    '''


    def peerList(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/peers/list"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint

        req = requests.post(url, headers=headers, verify=VERIFY_SSL)
        parsed = json.loads(req.content)
        results = parsed['data']['peers'] if 'data' in parsed else ''

        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('Picus-Peer-List', results)
            }
    '''Response:
    {
      "data": {
        "peers": [
          {
            "is_alive": true,
            "latest_attack": "2020-09-04T13:26:03.524Z",
            "name": "Windows10-Peer",
            "registered_ip": "\"\"",
            "type": "Network"
          }
        ],
        "total_count": 0
      },
      "success": true
    }
    '''


    def attackAllVectors(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/schedule/attack/all-possible-vectors"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        threat_id = int(demisto.args().get('threat_id'))
        data = { 'threat_id' : threat_id}
        try:
            req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        except Exception as e:
            print(e)
        parsed = json.loads(req.content)

        results = parsed['data']['vectors'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Attack-All-Vectors', results)
            }
    '''Response:
    {
      "data": {
        "vectors": [
          {
            "trusted": "string",
            "untrusted": "string",
            "variants": [
              {
                "name": "string",
                "result": "success"
              }
            ]
          }
        ]
      },
      "success": true
    }
    '''


    def attackSingle(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/schedule/attack/single"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        threat_id = int(demisto.args().get('threat_id'))
        variant = demisto.args().get('variant')
        vector1 = demisto.args().get('vector1')
        vector2 = demisto.args().get('vector2')
        data = { 'threat_id':threat_id,
                 'variant':variant,
                 'trusted':vector1,
                 'untrusted':vector2
        }

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed['data'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Attack-Single', results)
            }
    '''Response:
    {
      "data": {
        "result": "success"
      },
      "success": true
    }
    '''


    def triggerUpdate(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/settings/trigger-update"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint

        req = requests.post(url, headers=headers, verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Trigger-Update', results)
            }
    '''Response:
    {
      "data": true,
      "success": true
    }
    '''


    def version(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/settings/version"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint

        req = requests.post(url, headers=headers, verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed['data'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Version', results)
            }
    '''Response:
    {
      "data": {
        "last_update_date": "string",
        "update_time": 0,
        "version": 0
      },
      "success": true
    }
    '''


    def mitigationList(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/threats/mitigations/list"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        products = []
        begin_date = demisto.args().get('begin_date')
        end_date = demisto.args().get('end_date')
        page = int(demisto.args().get('page'))
        products = [demisto.args().get('products')]
        signature_id = demisto.args().get('signature_id')
        size = int(demisto.args().get('size'))
        threat_id = int(demisto.args().get('threat_id'))

        data = { 'begin_date':begin_date,
                 'end_date':end_date,
                 'page':page,
                 'products':products,
                 'signature_id':signature_id,
                 'size':size,
                 'threat_id':threat_id
        }

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed['data']['mitigations'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Mitigation-List', results)
            }
    '''Response:
    {
      "begin_date": "2018-10-29",
      "end_date": "2019-10-29",
      "page": 5,
      "products": "SourceFire IPS",
      "signature_id": "27726",
      "size": 10,
      "threat_id": 100682
    }
    '''


    def mitreMatrix(requestContent):

        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/threats/mitre-matrix"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint

        req = requests.get(url, headers=headers, verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed['data'] if 'data' in parsed else ''
        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown('PICUS-Mitre-Matrix', results)
            }
    '''Response:
    {
      "data": [
        {
          "tactic_id": 0,
          "tactic_name": "string",
          "techniques": [
            {
              "actions": [
                {
                  "action_id": "string",
                  "action_name": "string",
                  "affected_platforms": [
                    {
                      "architecture": "string",
                      "platform": "string"
                    }
                  ],
                  "description": "string",
                  "is_critical": true
                }
              ],
              "technique_id": "string",
              "technique_name": "string"
            }
          ]
        }
      ],
      "success": true
    }
    '''


    def sigmaRulesList(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/threats/sigma-rules/list"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint

        size = int(demisto.args().get('size'))
        page = int(demisto.args().get('page'))

        data = {
                 'Page Size':size,
                 'Page':page,
        }

        header = ['Sigma Rule List Count','Size', 'Page']
        result_info = {}

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)
        results = parsed['data']['sigma_rules'] if 'data' in parsed else ''

        result_info['Sigma Rule List Count'] = parsed['data']['total_count'] if 'data' in parsed else ''
        hr = tableToMarkdown('Sigma Rule List Info', result_info, header, removeNull=True)
        hr += tableToMarkdown('Sigma Rules', results)

        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr
            }

    '''Response:
    {
      "data": {
        "page_number": 2,
        "sigma_rules": [
          {
            "actions": [
              {
                "description": "string",
                "id": 0,
                "name": "string"
              }
            ],
            "content": "title: Gathering PnP Device List Information via powershell status: experimental...",
            "id": 0
          }
        ],
        "size": 5,
        "total_count": 548
      },
      "success": true
    }
    '''


    def vectorList(requestContent):
        SERVER = demisto.params().get('server')[:-1] if str(demisto.params().get('server')).endswith('/') \
        else demisto.params().get('server')
        endpoint = "/user-api/v1/vectors/list"

        accessToken = "Bearer " + requestContent

        headers = { "X-Api-Token":accessToken }

        url = SERVER + endpoint
        add_user_details = bool(demisto.args().get('add_user_details'))
        page = int(demisto.args().get('page'))
        size = int(demisto.args().get('size'))
        data = { 'add_user_details':add_user_details,
                 'page':page,
                 'size':size
        }

        req = requests.post(url, headers=headers, data=json.dumps(data), verify=VERIFY_SSL)
        parsed = json.loads(req.content)

        results = parsed['data']['vectors'] if 'data' in parsed else ''

        header = ['name','description','trusted','untrusted','is_disabled','type']
        hr = tableToMarkdown('Picus Vector List', results, header, removeNull=True)

        return {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr
            }
    '''Response:
    {
      "data": {
        "page_number": 2,
        "size": 5,
        "total_count": 548,
        "vectors": [
          {
            "description": "string",
            "heartbeat_results": [
              {
                "is_successful": true,
                "module": "PTS",
                "result_time": "2018-08-21T13:00:33.590599407Z",
                "variant": "HTTP"
              }
            ],
            "is_disabled": true,
            "name": "Email-Peer-2 - Email-Peer-1",
            "trusted": "Windows10-Peer",
            "type": "string",
            "untrusted": "Network-Peer",
            "users": [
              {
                "role": "admin",
                "username": "oliver"
              }
            ]
          }
        ]
      },
      "success": true
    }
    '''


    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """

        ''' EXECUTION '''
        #LOG('command is %s' % (demisto.command(), ))
        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            LOG('Command being called is {command}'.format(command=demisto.command()))
            if demisto.command() == 'Picus-GetAccessToken':
                getAccessToken()
            elif demisto.command() == 'Picus-Vector-Compare':#Makes a comparison of the given vector's results
                token = getAccessToken()
                demisto.results(vectorCompare(token))
            elif demisto.command() == 'Picus-Attack-Result-List':#Returns the list of the attack results\nhave optional parameters for pagination and filtration
                token = getAccessToken()
                demisto.results(attackResultList(token))
            elif demisto.command() == 'Picus-Specific-Threats-Results':#Returns the list of the attack results of a single threat\nhave optional
                token = getAccessToken()
                demisto.results(specificThreatsResults(token))
            elif demisto.command() == 'Picus-Peer-List':#Returns the peer list with current statuses
                token = getAccessToken()
                demisto.results(peerList(token))
            elif demisto.command() == 'Picus-EMail-Peer-List':#Returns the E-Mail peer list with current statuses
                token = getAccessToken()
                demisto.results(eMailPeerList(token))
            elif demisto.command() == 'Picus-Attack-All-Vectors':#Schedules given attack on all possible vectors
                token = getAccessToken()
                demisto.results(attackAllVectors(token))
            elif demisto.command() == 'Picus-Attack-Single':#Schedules a single attack on requested vector
                token = getAccessToken()
                demisto.results(attackSingle(token))
            elif demisto.command() == 'Picus-Trigger-Update':#Triggers the update mechanism manually, returns if the update-command is taken successfully
                token = getAccessToken()
                demisto.results(triggerUpdate(token))
            elif demisto.command() == 'Picus-Version':#Returns the current version and the update time config
                token = getAccessToken()
                demisto.results(version(token))
            elif demisto.command() == 'Picus-Threat-List':#Returns the list of the threats\nhave optional parameters for pagination and filtration
                token = getAccessToken()
                demisto.results(threatList(token))
            elif demisto.command() == 'Picus-Mitigation-List':#Returns the list of the mitigations of threats\nhave optional parameters for pagination and filtration, this route may not be used associated with your license
                token = getAccessToken()
                demisto.results(mitigationList(token))
            elif demisto.command() == 'Picus-Mitre-Matrix':#Returns the mitre matrix metadata\ntakes no parameters
                token = getAccessToken()
                demisto.results(mitreMatrix(token))
            elif demisto.command() == 'Picus-Sigma-Rules-List':#Returns the list of the sigma rules of scenario actions\nhave optional parameters for pagination and filtration, this route may not be used associated with your license
                token = getAccessToken()
                demisto.results(sigmaRulesList(token))
            elif demisto.command() == 'Picus-Vector-List':#Returns the list of the vectors all disabled and enabled ones\nhave optional parameters for pagination
                token = getAccessToken()
                demisto.results(vectorList(token))
            elif demisto.command() == 'test-module':
                demisto.results(test_module())

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  type: python
  commands:
  - name: Picus-Vector-Compare
    arguments:
    - name: begin_date
      required: true
      description: Result begin date
    - name: end_date
      required: true
      description: Result end date
    - name: trusted
      required: true
      description: Victem Peer
    - name: untrusted
      required: true
      description: Attacker Peer
    description: 'Attack Result - Makes a comparison of the given vector''s results.
      Example Command: !Picus-Vector-Compare begin_date=2020-01-20 end_date=2021-01-20
      trusted=Trusted_Peer1 untrusted=Untrusted_Peer1'
  - name: Picus-Attack-Result-List
    arguments:
    - name: attack_result
      required: true
      auto: PREDEFINED
      predefined:
      - secure
      - insecure
      description: Attack results that should be filtered. Secure or Insecure
      defaultValue: insecure
    - name: begin_date
      required: true
      description: Threat release date filter start of the date range
    - name: console_output_info
      description: 'Default: false -  Process Results of Scenario Details have console
        output information which can be in large sizes so this data is disabled by
        default'
      defaultValue: "False"
    - name: end_date
      required: true
      description: "\t string Default: \"Today's date formatted YYYY-mm-dd\" Threat
        release date filter end of the date range if a begin date is given and end
        date not, default will be used"
    - name: from_time
      description: 'Default: "null" allowed time formats RFC822, RFC822Z, RFC1123,
        RFC1123Z, RFC850, RFC3339'
      defaultValue: "null"
    - name: page
      description: 'Default: 1 Requested page number'
      defaultValue: "1"
    - name: size
      default: true
      description: 'Default: 50 Requested data size'
      defaultValue: "50"
    - name: threat_parameters
      description: '"threat_parameters": { "begin_date": "2018-10-29", "categories":
        [ [ "Malicious Code" ], [ "Attack Scenario", "Defense Evasion", "Indicator
        Removal from Tools" ] ],'
    - name: vector1
      required: true
      description: ' Array of objects (PeerPairParams) Vectors.(Trusted Peer)'
    - name: vector2
      required: true
      description: ' Array of objects (PeerPairParams) Vectors.(Untrusted Peer)'
    description: Returns the list of the attack results\nhave optional parameters
      for pagination and filtration. \nExample Command:\n !PICUS-Attack-Result-List
      attack_result=insecure begin_date=2020-01-01 end_date=2020-09-05  vector1=Trusted-Peer1
      vector2=Untrusted-Peer1
  - name: Picus-Specific-Threats-Results
    arguments:
    - name: cve
      description: CVE code of the threat to be filtered
    - name: md5
      description: The md5 of the threat
    - name: page
      description: 'integer <int64> -  Default: 1 Requested page number'
      defaultValue: "1"
    - name: sha256
      description: SHA256 hash of the threat
    - name: size
      description: 'integer <int64> - Default: 50 Requested data size'
      defaultValue: "50"
    - name: threat_id
      required: true
      description: integer <int64> PID of the threat
    description: 'Returns the list of the attack results of a single threat\nhave
      optional parameters for pagination and filtration. Example Command: !Picus-Specific-Threats-Results
      threat_id=666059'
  - name: Picus-Peer-List
    arguments: []
    description: Returns the peer list with current statuses
  - name: Picus-Attack-All-Vectors
    arguments:
    - name: threat_id
      required: true
      description: 'Example: threat_id=100682 PID of the threat'
    description: Schedules given attack on all possible vectors
  - name: Picus-Attack-Single
    arguments:
    - name: threat_id
      required: true
      description: 'Example: threat_id=666059 PID of the threat'
    - name: variant
      required: true
      description: 'Example: variant=HTTP'
    - name: vector1
      required: true
      description: 'Example: trusted=Trusted-Peer-Name Trusted peer name, if type
        is overall, it is not necessary'
    - name: vector2
      required: true
      description: 'Example: untrusted=Untrusted-Peer-Name Untrusted peer name, if
        type is overall, it is not necessary'
    description: Schedules a single attack on requested vector
  - name: Picus-Trigger-Update
    arguments: []
    description: Triggers the update mechanism manually, returns if the update-command
      is taken successfully
  - name: Picus-Version
    arguments: []
    description: Returns the current version and the update time config
  - name: Picus-Mitigation-List
    arguments:
    - name: begin_date
      required: true
      description: Threat release date filter start of the date range
    - name: end_date
      required: true
      description: 'Default: "Today''s date formatted YYYY-mm-dd" Threat release date
        filter end of the date range if a begin date is given and end date not, default
        will be used'
    - name: page
      description: "\t integer <int64> Default: 1 Requested page number"
      defaultValue: "1"
    - name: products
      required: true
      auto: PREDEFINED
      predefined:
      - ""
      - ""
      description: Array of strings - Products info of the mitigation
      isArray: true
    - name: signature_id
      required: true
      description: ID of the signature
    - name: size
      description: "\t integer <int64> - Default: 50 Requested data size"
      defaultValue: "50"
    - name: threat_id
      required: true
      description: integer <int64> -  PID of the threat
    description: 'Returns the list of the mitigations of threats\nhave optional parameters
      for pagination and filtration, this route may not be used associated with your
      license. Example Command: !Picus-Mitigation-List begin_date=2021-01-01 end_date=2021-02-01
      threat_id=528370 products="McAfee IPS" signature_id=0x40208a00'
  - name: Picus-Mitre-Matrix
    arguments: []
    description: Returns the mitre matrix metadata\ntakes no parameters
  - name: Picus-Sigma-Rules-List
    arguments:
    - name: size
      description: Size of Displayed Rule
      defaultValue: "100"
    - name: page
      default: true
      description: Page of Displayed Rule
      defaultValue: "1"
    description: Returns the list of the sigma rules of scenario actions\nhave optional
      parameters for pagination and filtration, this route may not be used associated
      with your license
  - name: Picus-Vector-List
    arguments:
    - name: add_user_details
      description: boolean - Add vectors' assigned user details to the response
      defaultValue: "True"
    - name: page
      description: 'Default: 1 Requested page number'
      defaultValue: "1"
    - name: size
      description: 'Default: 50 Requested data size'
      defaultValue: "50"
    description: Returns the list of the vectors all disabled and enabled ones\nhave
      optional parameters for pagination
  dockerimage: demisto/python3:3.8.3.9324
  runonce: false
  subtype: python3
sourcemoduleid: PICUS
